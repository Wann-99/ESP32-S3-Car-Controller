<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>舵机控制测试</title>
    <link rel="icon" type="image/svg+xml" href="favicon.ico">
    <style>
        body { font-family: Arial; text-align: center; margin: 20px; background: #f0f0f0; }
        .container { max-width: 400px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .speed-control { margin: 20px 0; }
        .servo-buttons { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            margin-top: 10px; 
            gap: 15px; 
        }
        .servo-adjuster {
            display: flex;
            border: 2px solid #607D8B;
            border-radius: 25px;
            overflow: hidden;
        }
        .servo-buttons .control-btn { 
            width: 45px; 
            height: 45px; 
            font-size: 20px; 
            font-weight: bold;
            background: #607D8B; 
            color: white; 
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .servo-buttons .control-btn:hover {
            background: #546E7A;
        }
        .servo-buttons .control-btn:active {
            background: #455A64;
        }
        .servo-buttons .control-btn.decrease {
            border-radius: 0;
        }
        .servo-buttons .control-btn.increase {
            border-radius: 0;
        }
        .servo-buttons input[type="number"] { 
            text-align: center; 
            border: 1px solid #ccc; 
            border-radius: 5px; 
            padding: 5px; 
            font-size: 14px; 
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>舵机控制测试</h2>
        
        <div class="speed-control">
            <label for="servoSlider">舵机控制: </label>
            <input type="range" id="servoSlider" min="0" max="180" step="0.09" value="90" onchange="setServo(this.value)" title="舵机角度滑块控制" aria-label="舵机角度滑块控制，逻辑角度0-180度">
            <div>逻辑角度: <span id="servoAngle">90</span>° <small style="color: #666;">(实际物理角度约为±60°范围)</small></div>
            <div class="servo-buttons">
                <div class="servo-adjuster">
                    <button class="control-btn decrease" onmousedown="startAdjust(-1)" onmouseup="stopAdjust()" onmouseleave="stopAdjust()" title="减少舵机角度" aria-label="减少舵机角度">-</button>
                    <button class="control-btn increase" onmousedown="startAdjust(1)" onmouseup="stopAdjust()" onmouseleave="stopAdjust()" title="增加舵机角度" aria-label="增加舵机角度">+</button>
                </div>
                <label for="servoInput" class="sr-only">舵机角度数值输入</label>
                <input type="number" id="servoInput" min="0" max="180" step="0.09" value="90" onchange="setServoFromInput(this.value)" style="width: 60px; margin: 0 5px;" placeholder="角度" title="直接输入舵机逻辑角度" aria-label="舵机角度数值输入，逻辑角度0-180度">
            </div>
            <div style="font-size: 12px; color: #888; margin-top: 5px;">
                角度说明：0°(左极限) → 90°(中位) → 180°(右极限)<br>
                实际物理转动约120°，避免极限位置保护舵机
            </div>
            <div id="status" style="margin-top: 10px; font-weight: bold;">检查连接中...</div>
        </div>
    </div>

    <script>
        // Variables for continuous servo adjustment (重新设计)
        let adjustInterval = null;
        let adjustDirection = 0;
        let lastServoCommand = 0; // 记录上次发送命令的时间
        let pendingServoAngle = null; // 待发送的角度
        let servoCommandTimeout = null; // 防抖定时器
        let isAdjusting = false; // 新增：调整状态标志
        
        // 添加连接状态检测
        let connectionStatus = true;
        let retryCount = 0;
        const maxRetries = 3;
        
        // ESP32 IP address - 需要根据实际IP地址修改
        const ESP32_IP = 'http://192.168.1.225'; // 直接使用ESP32的实际IP地址
        
        // 检查与ESP32的连接状态
        function checkConnection() {
            // 创建AbortController用于更好的请求控制
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 2000); // 2秒超时
            
            fetch(`${ESP32_IP}/api?action=distance`, {
                method: 'GET',
                mode: 'cors',
                signal: controller.signal,
                headers: {
                    'Content-Type': 'application/json',
                    'Cache-Control': 'no-cache',
                    'Connection': 'keep-alive',
                    'Accept': 'application/json'
                }
            })
            .then(response => {
                clearTimeout(timeoutId);
                if (response.ok) {
                    connectionStatus = true;
                    retryCount = 0;
                    document.getElementById('status').textContent = '连接正常';
                    document.getElementById('status').style.color = 'green';
                } else {
                    throw new Error(`服务器响应错误: ${response.status}`);
                }
            })
            .catch(error => {
                clearTimeout(timeoutId);
                connectionStatus = false;
                retryCount++;
                
                // 根据错误类型提供更详细的状态信息
                if (error.name === 'AbortError') {
                    document.getElementById('status').textContent = `连接超时 (重试 ${retryCount}/${maxRetries})`;
                    document.getElementById('status').style.color = 'orange';
                } else if (error.message.includes('ERR_CONNECTION_RESET') || error.message.includes('Failed to fetch')) {
                    document.getElementById('status').textContent = `ESP32离线 (重试 ${retryCount}/${maxRetries})`;
                    document.getElementById('status').style.color = 'red';
                } else {
                    document.getElementById('status').textContent = `连接异常 (重试 ${retryCount}/${maxRetries})`;
                    document.getElementById('status').style.color = 'red';
                }
                
                if (retryCount < maxRetries) {
                    setTimeout(checkConnection, 3000); // 增加重试间隔到3秒
                }
            });
        }
        
        // 页面可见性变化处理（优化刷新后的连接恢复）
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                // 页面变为可见时，重置连接状态并立即检查
                console.log('页面变为可见，重新检查连接');
                connectionStatus = false;
                retryCount = 0;
                setTimeout(checkConnection, 500); // 延迟500ms后检查，避免过快请求
            }
        });
        
        // 页面加载完成后的初始化
        window.addEventListener('load', function() {
            console.log('页面加载完成，初始化连接检查');
            // 重置所有状态
            connectionStatus = false;
            retryCount = 0;
            adjustDirection = 0;
            adjustInterval = null;
            
            // 延迟1秒后开始连接检查，确保页面完全加载
            setTimeout(checkConnection, 1000);
        });
        
        // 添加页面卸载前的清理
        window.addEventListener('beforeunload', function() {
            // 停止所有调整和定时器
            stopAdjust();
            
            // 清除所有定时器
            if (servoCommandTimeout) {
                clearTimeout(servoCommandTimeout);
                servoCommandTimeout = null;
            }
        });
        
        // 添加鼠标离开页面时的安全停止
        document.addEventListener('mouseleave', function() {
            // 当鼠标离开页面时，停止连续调整
            stopAdjust();
        });
        
        // 添加键盘事件处理（ESC键停止调整）
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                stopAdjust();
                console.log('ESC键按下，停止舵机调整');
            }
        });
        
        // 每10秒检查一次连接状态
        setInterval(checkConnection, 10000);
        // 页面加载时立即检查（保留原有逻辑）
        checkConnection();
        
        function setServo(angle) {
            angle = parseFloat(angle);
            document.getElementById('servoAngle').textContent = angle.toFixed(2);
            document.getElementById('servoInput').value = angle.toFixed(2);
            
            // 使用防抖机制发送舵机控制命令
            sendServoCommandDebounced(angle);
            console.log('设置舵机角度:', angle);
        }
        
        // 防抖的舵机控制命令发送
        function sendServoCommandDebounced(angle) {
            pendingServoAngle = angle;
            
            // 清除之前的定时器
            if (servoCommandTimeout) {
                clearTimeout(servoCommandTimeout);
            }
            
            // 设置防抖延迟，减少请求频率
            servoCommandTimeout = setTimeout(() => {
                const now = Date.now();
                // 限制最小请求间隔为200ms，减少网络负载
                if (now - lastServoCommand >= 200) {
                    sendServoCommand(pendingServoAngle);
                    lastServoCommand = now;
                } else {
                    // 如果间隔太短，再次延迟
                    setTimeout(() => {
                        sendServoCommand(pendingServoAngle);
                        lastServoCommand = Date.now();
                    }, 200 - (now - lastServoCommand));
                }
            }, 100); // 增加防抖延迟到100ms，减少请求频率
        }
        
        // 发送舵机控制命令到ESP32
        function sendServoCommand(angle) {
            // 检查连接状态
            if (!connectionStatus) {
                console.log('连接异常，跳过舵机命令');
                return;
            }
            
            // 限制角度范围
            angle = Math.max(0, Math.min(180, angle));
            
            // 四舍五入到0.09度的倍数
            angle = Math.round(angle / 0.09) * 0.09;
            
            // 保留两位小数
            angle = parseFloat(angle.toFixed(2));
            
            console.log(`发送舵机命令: ${angle}度`);
            
            const url = `${ESP32_IP}/api?action=servo&value=${angle}`;
            
            // 创建AbortController用于更好的请求控制
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 3000); // 减少超时时间到3秒
            
            fetch(url, {
                method: 'GET',
                mode: 'cors',
                signal: controller.signal,
                headers: {
                    'Content-Type': 'application/json',
                    'Cache-Control': 'no-cache',
                    'Connection': 'keep-alive',
                    'Accept': 'application/json'
                }
            })
            .then(response => {
                clearTimeout(timeoutId);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('舵机控制成功:', data);
                // 更新连接状态为正常
                connectionStatus = true;
                retryCount = 0;
                document.getElementById('status').textContent = '连接正常';
                document.getElementById('status').style.color = 'green';
            })
            .catch(error => {
                clearTimeout(timeoutId);
                console.error('舵机控制错误:', error);
                
                // 根据错误类型提供更详细的状态信息
                if (error.name === 'AbortError') {
                    connectionStatus = false;
                    document.getElementById('status').textContent = '请求超时';
                    document.getElementById('status').style.color = 'orange';
                } else if (error.message.includes('ERR_CONNECTION_RESET') || error.message.includes('Failed to fetch')) {
                    connectionStatus = false;
                    document.getElementById('status').textContent = 'ESP32连接断开';
                    document.getElementById('status').style.color = 'red';
                } else if (error.message.includes('HTTP error')) {
                    connectionStatus = false;
                    document.getElementById('status').textContent = `服务器错误: ${error.message}`;
                    document.getElementById('status').style.color = 'red';
                } else {
                    connectionStatus = false;
                    document.getElementById('status').textContent = '网络异常';
                    document.getElementById('status').style.color = 'red';
                }
            });
        }
        
        // Start continuous adjustment (重新设计)
        function startAdjust(direction) {
            console.log(`[DEBUG] startAdjust called with direction: ${direction}`);
            
            // 防止重复启动
            if (isAdjusting) {
                console.log(`[DEBUG] Already adjusting, ignoring startAdjust`);
                return;
            }
            
            isAdjusting = true;
            adjustDirection = direction;
            
            // 立即执行一次调整
            adjustServoByStep(direction * 1); // 1 degree step
            
            // 延迟启动连续调整
            const startTimeout = setTimeout(() => {
                if (isAdjusting && adjustDirection === direction) {
                    console.log(`[DEBUG] Starting continuous adjustment with direction: ${direction}`);
                    const intervalId = setInterval(() => {
                        if (isAdjusting && adjustDirection === direction) {
                            adjustServoByStep(direction * 1);
                        } else {
                            console.log(`[DEBUG] Stopping interval due to state change`);
                            clearInterval(intervalId);
                            adjustInterval = null;
                        }
                    }, 300);
                    
                    // 更新interval引用
                    adjustInterval = { timeout: null, interval: intervalId };
                } else {
                    console.log('连续调整被取消，方向已改变');
                }
            }, 800);
            
            // 保存超时ID，以便在停止时清除
            adjustInterval = { timeout: startTimeout, interval: null };
        }
        
        // Stop continuous servo adjustment (重新设计)
        function stopAdjust() {
            console.log(`[DEBUG] stopAdjust called`);
            
            // 立即停止调整状态
            isAdjusting = false;
            adjustDirection = 0;
            
            // 清除所有相关的定时器
            if (adjustInterval) {
                if (adjustInterval.timeout) {
                    clearTimeout(adjustInterval.timeout);
                    console.log(`[DEBUG] Clearing timeout timer`);
                }
                if (adjustInterval.interval) {
                    clearInterval(adjustInterval.interval);
                    console.log(`[DEBUG] Clearing interval timer`);
                }
                adjustInterval = null;
            }
            
            console.log(`[DEBUG] stopAdjust completed - isAdjusting: ${isAdjusting}, adjustDirection: ${adjustDirection}`);
        }
        
        // Adjust servo by step (重新设计)
        function adjustServoByStep() {
            if (!isAdjusting || adjustDirection === 0) {
                console.log(`[DEBUG] adjustServoByStep skipped - isAdjusting: ${isAdjusting}, adjustDirection: ${adjustDirection}`);
                return;
            }
            
            const slider = document.getElementById('servoSlider');
            const currentAngle = parseFloat(slider.value);
            const adjustment = adjustDirection * 1; // 1 degree step
            let newAngle = currentAngle + adjustment;
            
            // 限制角度范围
            newAngle = Math.max(0, Math.min(180, newAngle));
            
            // 角度精度处理
            newAngle = Math.round(newAngle / 0.09) * 0.09;
            newAngle = Math.round(newAngle * 100) / 100;
            
            console.log(`[DEBUG] adjustServoByStep: ${currentAngle} -> ${newAngle} (direction: ${adjustDirection})`);
            
            // 更新界面
            slider.value = newAngle;
            document.getElementById('servoInput').value = newAngle;
            
            // 发送命令
            setServo(newAngle);
        }
        
        function setServoFromInput(angle) {
            angle = parseFloat(angle);
            angle = Math.max(0, Math.min(180, angle));
            angle = Math.round(angle / 0.09) * 0.09;
            
            document.getElementById('servoSlider').value = angle;
            document.getElementById('servoInput').value = angle.toFixed(2);
            setServo(angle);
        }
    </script>
</body>
</html>